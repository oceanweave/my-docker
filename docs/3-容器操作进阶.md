## 1. 容器 detach（-d 参数）

- [从零开始写 Docker(八)---实现 mydocker run -d 支持后台运行容器 -](https://www.lixueduan.com/posts/docker/mydocker/08-mydocker-run-d/)

1. 容器进程的启动逻辑是  mydocker run --> mydocker init（替换为容器实际的进程），简化为 mydocker 主程序进程 --> 容器进程
2. -d 指的是 detach，目前功能有限，-it 和 -d 参数不能同时使用（-it 指的是前台与容器进程交互，-d 指的是容器进程后台运行）
3. 此处容器后台运行，实际上就是将 mydocker 主程序进程杀死，让容器进程被宿主机 1 号进程纳管
   - 因此有个 bug：容器进程结束后，相应的 overlayfs 目录和 cgroup 等资源无法进行清理
   - 个人理解：此处与 docker 的 -d （容器进程后台运行）有差异，此处 -d 相当于模拟 docker 主进程被杀死后，容器进程被宿主机1号进程纳管

## 2. 容器信息记录（-name 参数，模拟 ps）

- [从零开始写 Docker(九)---实现 mydocker ps 查看运行中的容器 -](https://www.lixueduan.com/posts/docker/mydocker/09-mydocker-ps/)

### 2.1 持久化容器信息到宿主机 json 文件

1. 利用随机函数创建容器 ID（containerID）
2. run 命令增加参数 -name，可指定容器名称
3. 创建容器，记录容器信息（containerID 和 containerName 等，若未指定 -name， containerName=containerID）到宿主机上指定的 config.json 中

``` sh
$ go build .
$ ./my-docker run -it -name test sh
{"level":"debug","msg":"Current containerID is [4254293419]","time":"2025-02-28T15:09:22+08:00"}
{"level":"debug","msg":"ContainerInfo save path: /var/lib/mydocker/containers/4254293419/config.json","time":"2025-02-28T15:09:22+08:00"}

# 新开启个终端
# 上面容器终止退出后，该文件会被清理掉
$ cat /var/lib/mydocker/containers/4254293419/config.json
{"pid":"63051","id":"4254293419","name":"test","command":"sh","createdTime":"2025-02-28 15:09:22","status":"running"}
```

![持久化容器信息](imgs/3-容器操作进阶/持久化容器信息.png)